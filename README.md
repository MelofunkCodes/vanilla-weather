Replicating the Weather App project found in https://github.com/DecodeMTL/vanilla-js-projects

Demo available at https://melofunkcodes.github.io/vanilla-weather/

DETAILS:

## Project #1: Weather App

### Introduction
For this first project we will be holding your hand throughout. We will build a basic version of a weather application that shows the current temperature in a city. Here's what the final basic version of the project will look like:

<p align="center">
  <img src="weather-app-demo.gif">
</p>

As discussed in class, if you want to use this project as part of your portfolio it would be interesting for you to do more than the basic version. Some suggestions will be given to you at the end of the workshop instuctions :)

### Preparing
To prepare coding for the project, we will get ourselves some keys for the two APIs we will use.

#### Dark Sky Weather API
Let's get an API key for the Dark Sky API...

  1. Go to https://darksky.net/dev/ and signup
  2. Confirm your email
  3. Login and find your API key here https://darksky.net/dev/account
  4. Copy your API key somewhere, and we'll add it to the code later

<p align="center">
  <img src="dark-sky-api-key.png">
</p>

#### Google Maps Geocoding API
Let's get an API key for the Google Maps Geocoding API...

  1. Go to https://developers.google.com/maps/documentation/geocoding/get-api-key
  2. Click on "GET A KEY"
  3. Enter a name for your application
  4. Copy your API key somewhere, and we'll add it to the code later

<p align="center">
  <img src="google-maps-api-key.png">
</p>

### Let's start to code!
Our app will be composed of a basic `index.html` file that has the main user interface, and an `app.js` where all the interesting stuff will happen.

Create an `index.html` file with the following content:

```html
<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Weather App</title>
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div id="app">
      <h1>Weather App!</h1>
      <div class="main-app">
        <form class="city-form">
          <input type="text" class="city-input">
          <button type="button" class="get-weather-button">Get Weather!</button>
        </form>
        <div class="city-weather">
          <!-- the content diplayed here will be generated by DOM operations :) -->
        </div>
      </div>
    </div>
    <script src="app.js"></script>
  </body>
</html>
```

This HTML file lays out the structure of our application. As will always be the case, everything will happen inside the #app div. This is better than throwing everything directly in the body. Think of it as a namespace.

Then, let's create the `app.js` that our HTML is referring to. The first thing we'll do is add our API keys to the JavaScript file. Before that though, let's make sure our API keys are working.

Go to your browser and open the `index.html` file that you just created. Open the developer tools and move to the Console tab. Then, try running the following command, **making sure to replace the part that says `<YOUR API KEY HERE>` with your API key**.

```javascript
fetch('https://api.darksky.net/forecast/<YOUR API KEY HERE>/37.8267,-122.4233')
.then(response => response.json())
.then(data => console.log(data))
```

Oops! What happened? Dark Sky is preventing us to make HTTP requests to it from a browser. In a real application, this would make sense because your API key should be kept secret. If we were building a real application, we would have to create our **own web server that acts as a proxy to the Dark Sky API**. This way we could keep our API key hidden on the server, and even add our own logic to do rate limiting, caching and so on.

Since we are in development mode here, we are going to use a shortcut. A service called [CORS Anywhere](https://cors-anywhere.herokuapp.com/) will allow us to proxy our requests through it, and that service will automatically add the appropriate `Access-Control-Allow-Origin` header in its response. But wait... How can such a service exist? Isn't it unsafe to allow us to make AJAX calls to a site that doesn't allow it in the first place? Well, not really. If our browser is making request to the CORS Anywhere domain, then the cookies of the original website will not be passed along, so we will get a pretty generic response. In our case, we're using this to bypass the Dark Sky protection of our API key. We simply have to know that what we're doing would be bad in a real application where our secret API key would become exposed.

Let's try that same request but make it go thru the CORS Anywhere proxy:

```javascript
fetch('https://cors-anywhere.herokuapp.com/https://api.darksky.net/forecast/<YOUR API KEY HERE>/37.8267,-122.4233')
.then(response => response.json())
.then(data => console.log(data))
```

Finally we are getting some data! The URL looks weird, but basically everything after the `herokuapp.com/` will be passed as the path to the proxy, and the proxy will make the request on our behalf from the server-side, safe of any cookies.

The Google Maps API does not have this limitation, so we can geocode directly from the browser. Try it anyway just to be sure that your API key works:

```javascript
fetch('https://maps.googleapis.com/maps/api/geocode/json?address=montreal&key=<YOUR API KEY HERE>')
.then(response => response.json())
.then(data => console.log(data))
```

Now that we've tested our APIs, let's add the necessary information to our `app.js` file. Create the file and add the following code in it:

```javascript
var DARKSKY_API_URL = 'https://api.darksky.net/forecast/';
var DARKSKY_API_KEY = 'YOUR API KEY HERE';
var CORS_PROXY = 'https://cors-anywhere.herokuapp.com/';

var GOOGLE_MAPS_API_KEY = 'YOUR API KEY HERE';
var GOOGLE_MAPS_API_URL = 'https://maps.googleapis.com/maps/api/geocode/json';
```

Next, we'll create some utility functions that will allow us to access the two APIs and return only the data that we need.

Let's start by creating a function called `getCoordinatesForCity`. The function will take a city string as parameter, and return a Promise for a coordinates object. Here is the code of the function, add it to your `app.js`:

```javascript
// This function returns a promise that will resolve with an object of lat/lng coordinates
function getCoordinatesForCity(cityName) {
  // This is an ES6 template string, much better than verbose string concatenation...
  var url = `${GOOGLE_MAPS_API_URL}?address=${cityName}&key=${GOOGLE_MAPS_API_KEY}`;

  return (
    fetch(url) // Returns a promise for a Response
    .then(response => response.json()) // Returns a promise for the parsed JSON
    .then(data => data.results[0].geometry.location) // Transform the response to only take what we need
  );
}
```

Test your function by going in the browser and refreshing your page. Since the `app.js` code we are writing is in the **global scope**, the function we just created is available. Call it like so:

```javascript
getCoordinatesForCity("montreal").then(console.log)
```

And make sure that you see an object with lat/lng properties printed out.

Then we'll add our second utility function called `getCurrentWeather`. It will take an object with lat/lng and query the Dark Sky API for the current weather. We only care about the current weather so we can optimize our API call. Let's add this to our `app.js`:

```javascript
function getCurrentWeather(coords) {
  // Template string again! I hope you can see how nicer this is :)
  var url = `${CORS_PROXY}${DARKSKY_API_URL}${DARKSKY_API_KEY}/${coords.lat},${coords.lng}?units=si&exclude=minutely,hourly,daily,alerts,flags`;

  return (
    fetch(url)
    .then(response => response.json())
    .then(data => data.currently)
  );
}
```

Same idea, different API. The `units=si&exclude=minutely,hourly,daily,alerts,flags` part in the query string of the URL is explained in the [Dark Sky API documentation](https://darksky.net/dev/docs/forecast). Basically `units=si` means we'll get things back in celcius and kilometers, and the `exclude` says to only send us the `currently` data. It makes the API response smaller and therefore faster to transfer across the wire.

Again let's test our function by refreshing the browser and trying the following code:

```javascript
getCurrentWeather({lat: 45.5, lng: -73.5}).then(console.log)
```

This should print an object in the console that contains a bunch of weather properties. For the basic version we will only be using the temperature.

The two functions we created will make up our basic flow of data. We can test them together in the browser's console this way:

```javascript
getCoordinatesForCity("montreal")
.then(getCurrentWeather)
.then(data => console.log(`The current temperature is ${data.temperature}`));
```

This should print out the current temperature for the city you asked for.

:warning: :warning: :warning: **Before moving on the the next section, make sure that you understand everything that we did so far. Otherwise, if you simply copied and pasted what we gave you without understanding it, you will not have learned anything. If you cannot explain exactly what is going on, then ask one of your classmates or a TA to be sure.**

### Wiring it up to the DOM
We are building this project following a logical progression. If this was a console-based project, we would be done. The last section gave us the data that we needed, and we were able to print it on the console.

However, this project also has a user interface component. In the browser, the user interface is created by using HTML and CSS, along with JavaScript for DOM manipulations and events. This is exactly what we'll do in this section.

We already wrote the HTML for the user interface, and the CSS will be left to you as an optional but strongly suggested exercise. Let's write the JavaScript code for the UI now! First, let's create one variable for each DOM element we will need to target. Add the following code to `app.js`, after the two functions you wrote in the last section:

```javascript
var app = document.querySelector('#app');
var cityForm = app.querySelector('.city-form');
var cityInput = cityForm.querySelector('.city-input');
var getWeatherButton = cityForm.querySelector('.get-weather-button');
var cityWeather = app.querySelector('.city-weather');
```

Notice that we are introducing a new thing here: the `querySelector` method does not only exist on the document object, but also on all the elements inside the document. If we call `querySelector` on an element, we will only get back elements that are its descendants. This is much more robust than querying the whole document.

Now that we have a reference to all the needed DOM elements, let's wire up an event handler. We'll do it a first time the wrong way, then we'll see why it's wrong, and we'll fix it after :)

What we want to do is setup the app so that when the user clicks on the "Get Weather!" button, we start the process of fetching the data. Let's add the following code at the end of our `app.js`:

```javascript
getWeatherButton.addEventListener('click', function() {
  var city = cityInput.value; // Grab the current value of the input

  getCoordinatesForCity(city) // get the coordinates for the input city
  .then(getCurrentWeather) // get the weather for those coordinates
  .then(function(weather) {
    cityWeather.innerText = 'Current temperature: ' + weather.temperature;
  });
});
```

Refresh your browser, enter a city name and click the "Get Weather!" button. Wait a few seconds and you should see a message displayed in the page with the current temperature. We just AJAXed!

Now let's see why this is not the best way to setup our event... Refresh your browser, type a city name in the input field, and press ENTER on your keyboard. What's happening? Well by **default**, the browser tries to submit the form using the standard browser mechanism. Except our form is not meant to be submitted. Let's fix this!

First, go back to your HTML and change the `button type="button"` to `button type="submit"`. The button now becomes a submit button for the form. This means that now, whether you click the button or press ENTER in the input field, the form will first fire off a `submit` event. Let's change our event code a little bit to this:

```javascript
cityForm.addEventListener('submit', function(event) { // this line changes
  event.preventDefault(); // prevent the form from submitting

  // This code doesn't change!
  var city = cityInput.value;

  getCoordinatesForCity(city)
  .then(getCurrentWeather)
  .then(function(weather) {
    cityWeather.innerText = 'Current temperature: ' + weather.temperature;
  });
});
```

Now refresh the browser and try again. You should get a consistent behavior whether you press ENTER in the input field or click the "Get Weather!" button. We are done with the basics. Congrats :)

### Cleaning things up a bit...
Let's clean up our code a bit in two ways. First off notice that we're not using the `getWeatherButton` variable anymore so let's remove it from the code.

Then, let's clean up all the global variables that we just polluted our scope with. Whenver JavaScript runs in the context of your web page, it runs in the global scope. As you already know, one way to create a new scope in JavaScript is to write code inside a function. It turns out that all the code that we wrote in `app.js` doesn't need to expose any variables to the outside world. We only used those variables to help run our logic. In order to fix this, we will wrap **ALL** the code that we wrote inside a contraption called [IIFE, or Immediately Invoked Function Expression](http://benalman.com/news/2010/11/immediately-invoked-function-expression/). The code of `app.js` will look like this:

```javascript
(function() {
  var DARKSKY_API_URL = 'https://api.darksky.net/forecast/';
  var DARKSKY_API_KEY = 'YOUR API KEY HERE';
  var CORS_PROXY = 'https://cors-anywhere.herokuapp.com/';

  var GOOGLE_MAPS_API_KEY = 'YOUR API KEY HERE';
  var GOOGLE_MAPS_API_URL = 'https://maps.googleapis.com/maps/api/geocode/json';

  function getCurrentWeather(coords) {
    var url = `${CORS_PROXY}${DARKSKY_API_URL}${DARKSKY_API_KEY}/${coords.lat},${coords.lng}`;

    return (
      fetch(url)
      .then(response => response.json())
      .then(data => data.currently)
    );
  }

  function getCoordinatesForCity(cityName) {
    var url = `${GOOGLE_MAPS_API_URL}?address=${cityName}&key=${GOOGLE_MAPS_API_KEY}`;

    return (
      fetch(url)
      .then(response => response.json())
      .then(data => data.results[0].geometry.location)
    );
  }

  var app = document.querySelector('#app');
  var cityForm = app.querySelector('.city-form');
  var cityInput = cityForm.querySelector('.city-input');
  var getWeatherButton = cityForm.querySelector('.get-weather-button');
  var cityWeather = app.querySelector('.city-weather');

  cityForm.addEventListener('submit', function(event) {
    event.preventDefault(); // prevent the form from submitting

    var city = cityInput.value;

    getCoordinatesForCity(city)
    .then(getCurrentWeather)
    .then(function(weather) {
      cityWeather.innerText = 'Current temperature: ' + weather.temperature;
    })
  });
})();
```

This says here's an anonymous function, now run it. The advantage is that all the variables and functions we declared are now scoped to this function, and will not pollute the global scope! Since we don't need those variables outside of that scope, this is perfectly fine. **It is a good practice to wrap your code in an IIFE to prevent it from polluting the global scope. Do it whenever possible!** The reason for the extra parentheses is to prevent a `SyntaxError` as explained in the article linked above.

### Possible improvements
As discussed in class, if you want to use this project for your portfolio you can make a lot of enhancements to it. Here are some suggestions:

  1. When we click "Get Weather!" right now, there is no indication that the browser is doing anything useful. If the two API calls take more than a few milliseconds to run, we will not see what is going on. This is bad for the user experience. If you look at the GIF at the beginning of this seciton, you'll notice that after entering a city name the word "loading..." appears below, to be replaced by the result when it arrives. Implement this in your own app.
  2. Add CSS to make it look nice! Here, the sky is the limit ;) Bigger fonts, custom fonts, custom colors and backgrounds. You can use the [Skycons](http://darkskyapp.github.io/skycons/) icons since the API returns an `icon` property in the data. You could also look for another set of icons that is more original or in line with the style of your app.
  3. Add more weather information. The `currently` section contains the wind speed, wind direction, and many other interesting bits of information about the weather. Find a nice way to display them and do it!
  4. Add a five-day forecast to your application with its own styling and icons.
  5. When geocoding, we are taking the first result that Google Maps API gives us. Inside this result there is the full name of the location that we requested. For example if you query for `address=montreal`, the response will contain the string `Montreal, QC, Canada`. Use this to display it along with your weather information.
  6. Use [Google Places Autocomplete](https://developers.google.com/maps/documentation/javascript/places-autocomplete) to provide an input box that will suggest options to the user. This is better than "guessing" what the user wanted to type, and will make you learn about a new API.